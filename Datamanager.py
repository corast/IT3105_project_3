# Keep track of training data to use on the network, i.e. keep history of our plays.

# We need to store this incase we close our program, and want to keep training.
# Should be storer in a .csv file. for easy access next time.
# .CSV file should contain: A state input, Player ID , + Output on all states.  dimxdim + PID input + dimxdim output.
# The output of all states should be visits on all legal states, generated by the MCTS simulation
# * Replay buffer: each episode(game) contains m moves, which mean m cases for the replay buffer
# * The state input, should be two bits for each board cell. (0,0) for 0, (1,0) for player 1 and (1,1) for player 2.
# The PID should be two bits: (1,0) for player 1 and (1,1) for player 2.

import csv # Gives us the oppurtunity to write to an file.
import numpy as np
import random
#import pytorch.torch as torch
#import torch
import os
import misc
#import pandas

class Datamanager():
    def __init__(self, filepath, dim=5, limit=500):
        self.filepath = filepath
        self.limit = limit
        self.dim = dim # dim of game we use
        if(not os.path.isfile(filepath)):  # * Create filepath, if it doest exist already.
            with open (filepath,"a") as file:
                pass
        self.buffer = [] # An list, that contains target + training.

        # * check if there is something from previous buffer.
        prev_buff_size = self.get_buffer_size()
        if(prev_buff_size != 0):
            self.buffer = self.read_csv() # * fill our buffer

        self.__switcher = {
            1:self.normal,
            2:self.cnn,
            3:self.cnn_flatten
            }

    def read_csv(self,header=False): # amount is to specify whether or not we want all the file or not.
        # read the content of the csv file.
        file = []
        with open(self.filepath) as csv_file:
            csv_reader = csv.reader(csv_file,delimiter=",")

            line_count = 0
            for row in csv_reader:
                if(header and line_count == 0): # Handle header
                    #print("headers: {}".format(row))
                    line_count += 1
                else:
                    file.append(row)
                    #print(row)
                line_count += 1
        return file
    
    def update_buffer(self,data=[]): # Simply add one extra row to buffer array.
        
        self.buffer.extend([data]) # hopefully, we can add an extra row with out problems.
        if(len(self.buffer) > self.limit + 1):
            amount = len(self.buffer) - self.limit
            self.buffer = self.buffer[amount:] # Only keep limit


    def __update_csv(self,mode="a",header=[],data=[[]]): # Data should be an array of arrays, with all the data we need
        # The array must be [[row1],[row2]] etc. not [row1]
        # []
        # Mode specify if we want to replace the file with data parameter, or append new data.
        with open(self.filepath, mode=mode, newline="") as history_file:
            # Init writer to the file, with dialect
            dataset_writer = csv.writer(history_file, delimiter=",", quotechar='"', quoting=csv.QUOTE_MINIMAL)
            if(len(header) != 0):
                dataset_writer.writerow(header)
            # Write the actual data.
            for row in data:
                dataset_writer.writerow(row)

    def update_csv_limit(self, header=[]): 
        # Update the csv file, but only keep the top newest examples.
        # We need to remove from the bottom.
        #TODO: put buffer in memory instead, and write to csv after a game is finished, instead of every move.
        if(len(header) != 0):
            self.__update_csv(mode="w",header=header,data=self.buffer)
        else:
            self.__update_csv(mode="w",data=self.buffer)
        
    
    def return_num(self, num, tot_size):
        """ Return number of cases we want to keep. """
        # Either a fraction, all cases or a specific number.
        if(num != "all"):
            #check if an integer of a float.
            if(type(num) == float):  # if float
                if(num > 1):
                    num_floor = np.floor(num)
                    num = num - num_floor # only keep decimal places
                num = int(tot_size*num) # Keep only the specified fraction.

            if(tot_size < num):    
                num = tot_size
            return num
        return tot_size # Know we want all cases.

    def return_batch(self, batch_size): # Return tensor with batch_size from file.
        """ Return two tensors(inputs, targets) of size batch_size from bufferfile"""
        import torch
        #Handle converting data to correct network innput, CNN takes 3 channels.
        # Non CNN takes current setting.
        # Batch can actually be pulled from buffer, since it is the same.

        data = self.buffer
        tot_size = len(data) # Number of cases we got.

        # Num, is the amount of data we send back.
        num = self.return_num(batch_size, tot_size)

        if(tot_size == 0):
            raise ValueError("No cases availible in file {}".format(self.filepath))
        # Randomly select num unique cases
        data = random.sample(data, num) # We don't care about testing or validation at this stage
        data_pid = []
        data_inputs = []
        data_targets = []
        for i, row in enumerate(data):
            data_pid.append(int(row[0])) 
            input = list(map(int,row[1:(self.dim*self.dim)+1])) # 1-> 25 should be board
            target = list(map(float,row[(self.dim*self.dim)+1:]))
            data_inputs.append(input)
            data_targets.append(target)

        # Depending on modus: 
        #        
        t_inputs = self.__switcher.get(self.modus)(data_pid, data_inputs,self.dim) # Get inputs
        t_targets = torch.from_numpy(np.array(data_targets)).float()

        return t_inputs, t_targets

    def return_keras(self, modus):
        data = self.buffer
        tot_size = len(data)
        if(tot_size == 0):
            raise ValueError("No cases availible in file {}".format(self.filepath))
        data_pid = []
        data_inputs = []
        data_targets = []
        for i, row in enumerate(data):
            data_pid.append(int(row[0])) 
            input = list(map(int,row[1:(self.dim*self.dim)+1])) # 1-> 25 should be board
            target = list(map(float,row[(self.dim*self.dim)+1:]))
            data_inputs.append(input)
            data_targets.append(target)
        # return as numpy. arrays
        if(modus == 1):# * (B x 52)
            PID =  np.array([misc.int_to_binary_rev(pid) for pid in data_pid])
            inputs = np.array([misc.one_hot_array(board) for board in data_inputs])
            inputs = np.append(PID, inputs, axis=1)
        elif(modus == 2): # * (B x 3x5x5)
            PID = np.array([np.full((self.dim,self.dim),(2-pid)) for pid in data_pid]) # Player 2 = 0, Player 1 = 1
            inputs = np.array([misc.get_player_states(board,self.dim,ravel=False) for board in data_inputs])
            PID = np.reshape(PID,(PID.shape[0],1,PID.shape[1],PID.shape[2]))
            inputs = np.concatenate((inputs,PID),axis=1)
        elif(modus == 3): # * (B x 26)
            PID = np.array([misc.reverse_2([pid]) for pid in data_pid])
            inputs = np.array([misc.reverse_2(board) for board in data_inputs])
            inputs = np.append(PID, inputs, axis=1) 
        else:
            raise ValueError("Modus not supporter", modus)
        return inputs, np.array(data_targets)

    def return_batch_keras(self, batch_size):
        data = self.buffer
        tot_size = len(data)
        if(tot_size == 0):
            raise ValueError("No cases availible in file {}".format(self.filepath))
        data_pid = []
        data_inputs = []
        data_targets = []
        for i, row in enumerate(data):
            data_pid.append(int(row[0])) 
            input = list(map(int,row[1:(self.dim*self.dim)+1])) # 1-> 25 should be board
            target = list(map(float,row[(self.dim*self.dim)+1:]))
            data_inputs.append(input)
            data_targets.append(target)

        # return as numpy. arrays
        if(self.modus == 1):# * (B x 52)
            PID =  np.array([misc.int_to_binary_rev(pid) for pid in data_pid])
            inputs = np.array([misc.one_hot_array(board) for board in data_inputs])
            inputs = np.append(PID, inputs, axis=1)
        elif(self.modus == 2): # * (B x 3x5x5)
            PID = np.array([np.full((self.dim,self.dim),(2-pid)) for pid in data_pid]) # Player 2 = 0, Player 1 = 1
            inputs = np.array([misc.get_player_states(board,self.dim,ravel=False) for board in data_inputs])
            PID = np.reshape(PID,(PID.shape[0],1,PID.shape[1],PID.shape[2]))
            inputs = np.concatenate((inputs,PID),axis=1)
        return inputs, np.array(data_targets)

    def get_buffer_size(self):
        """ return number of rows in csv file"""
        data = self.read_csv()
        return len(data)

    def normal(self,data_pid,data_inputs,dim):
        import torch
        # inputs:  PID + board_state
        PID =  np.array([misc.int_to_binary_rev(pid) for pid in data_pid])
        inputs = np.array([misc.one_hot_array(board) for board in data_inputs])
        inputs = np.append(PID, inputs, axis=1)
        # * PID + board_state as one hot vectors per cell.
        return torch.from_numpy(inputs).float() # * (Bx52) 

    def cnn(self,data_pid,data_inputs,dim): # Tensor with shape (B,channels,dim,dim)
        import torch
        PID = np.array([np.full((self.dim,self.dim),(2-pid)) for pid in data_pid]) # Player 2 = 0, Player 1 = 1
        inputs = np.array([misc.get_player_states(board,self.dim,ravel=False) for board in data_inputs])
        PID = np.reshape(PID,(PID.shape[0],1,PID.shape[1],PID.shape[2]))
        inputs = np.concatenate((inputs,PID),axis=1)
        return torch.from_numpy(inputs).float() # * (B x 3 x 5 x 5) for CNN2d

    def cnn_flatten(self,data_pid, data_inputs, dim):# Tensor with shape (B, channels, dim*dim)
        import torch
        PID = np.array([np.full((self.dim*self.dim),(2-pid)) for pid in data_pid]) # Player 2 = 0, Player 1 = 1
        #inputs = torch.from_numpy(np.array([misc.get_player_states(board,self.dim,ravel=True) for board in data_inputs]))
        #boards = [misc.get_player_states(board,self.dim,ravel=True) for board in data_inputs] # return list of touples
        # Add PID to the boards.
        #print("boards",boards[0])
        inputs = np.array([misc.get_player_states(board,self.dim,ravel=True) for board in data_inputs])
        PID = np.reshape(PID,(PID.shape[0],1,PID.shape[1]))
        inputs = np.concatenate((inputs, PID),axis=1)

        return torch.from_numpy(inputs).float() # * (B x 3 x 25)  For CNN1d

    # Extra functions almost never used.

    def fix_board_state(self):
        raise Exception("Don't use this function..")
        print("Fixing", self.filepath)
        print("Before:",len(self.buffer),self.buffer[0])
        #data = self.read_csv() 
        # We want to get original board state from each row.
        # basicly remove dimx*dimx+2 from each row and translate back.
        # [0,0] -> 0, [0,1] -> 2, [1,0] -> 1.
        for r,row in enumerate(self.buffer):
            #Want to remove first 52 numbers.
            data = row
            board = row[:52] # first 52 numbers
            targets = row[52:] # target values
            new_row = []
            i = 0
            while i < len(board)-1:
                l_data = [board[i],board[i+1]] 
                if(l_data == ["1","0"]):
                    new_row.append("1")
                elif (l_data == ["0","1"]):
                    new_row.append("2")
                else:
                    new_row.append("0")
                i +=2
            self.buffer[r] = new_row + targets
        
        print("After:",len(self.buffer),self.buffer[0])
        self.update_csv_limit()

def test_return_batch():
    dataset = Datamanager("Data/data_r_test.csv",5)
    dataset.return_batch(10)

#test_dataset_write()